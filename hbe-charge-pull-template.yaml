apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: hbe-charge-pull-template
  namespace: argo-cicd
spec:
  securityContext:
    runAsNonRoot: false
  serviceAccountName: argo
  volumes:
    - name: shared-workspace
      persistentVolumeClaim:
        claimName: shared-data-pvc-2
    - name: credentials
      secret:
        secretName: deployment-ssh-keys
  templates:
    - name: hbe-charge-pull
      inputs:
        parameters:
          - name: branch
          - name: url
      volumes:
        - name: shared-workspace
          persistentVolumeClaim:
            claimName: shared-data-pvc-2
      container:
        image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/alpine/git:v2.49.0
        imagePullPolicy: IfNotPresent
        workingDir: /src/hbe-charge
        volumeMounts:
          - name: shared-workspace
            mountPath: /src
        env:
          - name: GIT_USERNAME
            valueFrom:
              secretKeyRef:
                name: gitlab-pull-secret
                key: username
          - name: GIT_PASSWORD
            valueFrom:
              secretKeyRef:
                name: gitlab-pull-secret
                key: password
        command: ["/bin/sh", "-c"]
        args:
          - |
            set -e

            echo "Debug: Starting pull task"
            echo "Raw branch parameter: {{inputs.parameters.branch}}"
            echo "URL parameter: {{inputs.parameters.url}}"

            # 输出完整的参数值用于调试
            echo "=== DEBUG EVENT PAYLOAD ==="
            echo "Branch parameter type: $(echo "{{inputs.parameters.branch}}" | jq -r 'type' 2>/dev/null || echo 'not json')"
            echo "Full branch parameter value:"
            echo "{{inputs.parameters.branch}}" | jq . 2>/dev/null || echo "{{inputs.parameters.branch}}"
            echo "=========================="

            # Extract branch name from full ref if needed
            BRANCH_NAME=$(echo "{{inputs.parameters.branch}}" | sed 's|refs/heads/||')
            echo "Debug: Extracted branch name: $BRANCH_NAME"

            # Additional debugging info
            echo "Debug: Full environment:"
            env | grep -i git || true


            # Pull code
            git init
            git config --global credential.helper store
            REPO_HOST=$(echo {{inputs.parameters.url}} | sed -e 's|https\?://||' -e 's|/.*||')
            echo "http://$GIT_USERNAME:$GIT_PASSWORD@$REPO_HOST" > ~/.git-credentials

            # Check if remote origin already exists
            if git remote get-url origin > /dev/null 2>&1; then
              echo "Remote origin already exists, updating URL"
              git remote set-url origin {{inputs.parameters.url}}
            else
              echo "Adding remote origin"
              git remote add origin {{inputs.parameters.url}}
            fi

            # 使用完整克隆而不是浅克隆，确保可以访问完整的Git历史记录
            echo "Fetching branch: $BRANCH_NAME"

            # 首先尝试获取远程分支
            if git fetch origin $BRANCH_NAME; then
              echo "Successfully fetched remote branch $BRANCH_NAME"
              git checkout FETCH_HEAD
            else
              echo "Failed to fetch remote branch $BRANCH_NAME, trying to clone default branch"
              # 如果获取特定分支失败，则克隆默认分支
              git fetch origin
              # 列出可用的远程分支
              echo "Available remote branches:"
              git branch -r
              
              # 尝试检出分支，如果失败则列出所有分支
              if ! git checkout $BRANCH_NAME; then
                echo "Failed to checkout branch $BRANCH_NAME"
                echo "Local branches:"
                git branch -a
                exit 1
              fi
            fi

            PROJECT_NAME=$(echo {{inputs.parameters.url}} | awk -F'/' '{print $NF}' | sed 's/\..*//')

            # 检查是否有变更文件
            git diff --name-only HEAD~1 HEAD > /tmp/changed-files.txt || touch /tmp/changed-files.txt

            # 检查是否有变更文件
            if [ ! -s /tmp/changed-files.txt ]; then
              echo "Error: No changed files detected, please check your commit content."
              exit 1
            fi

            # 用Set存储被修改的模块，防止重复
            BACKEND=0
            CSMS16=0
            CSMS201=0
            FRONTEND=0
            JOBS=0

            # 遍历所有修改的文件，确定它们属于哪些模块
            while IFS= read -r file; do
              echo "Processing file: $file"
              # 使用 [ ] 替代 [[ ]] 以确保与 sh 兼容
              # 使用双引号包裹变量以处理包含空格的文件名
              if [ "${file#app/backend/}" != "$file" ]; then
                echo "Matched backend module"
                BACKEND=1
              elif [ "${file#app/csms1.6/}" != "$file" ]; then
                echo "Matched csms1.6 module"
                CSMS16=1
              elif [ "${file#app/csms2.0.1/}" != "$file" ]; then
                echo "Matched csms2.0.1 module"
                CSMS201=1
              elif [ "${file#app/frontend/}" != "$file" ]; then
                echo "Matched frontend module"
                FRONTEND=1
              elif [ "${file#app/jobs/}" != "$file" ]; then
                echo "Matched jobs module"
                JOBS=1
              else
                echo "File $file did not match any module pattern"
              fi
            done < /tmp/changed-files.txt

            echo "Module flags - BACKEND:$BACKEND CSMS16:$CSMS16 CSMS201:$CSMS201 FRONTEND:$FRONTEND JOBS:$JOBS"

            # 构建模块列表
            MODULES=""
            if [ $BACKEND -eq 1 ]; then
              MODULES="${MODULES}backend,"
            fi
            if [ $CSMS16 -eq 1 ]; then
              MODULES="${MODULES}csms1.6,"
            fi
            if [ $CSMS201 -eq 1 ]; then
              MODULES="${MODULES}csms2.0.1,"
            fi
            if [ $FRONTEND -eq 1 ]; then
              MODULES="${MODULES}frontend,"
            fi
            if [ $JOBS -eq 1 ]; then
              MODULES="${MODULES}jobs,"
            fi

            echo "Modules string before trim: $MODULES"

            # 移除末尾的逗号
            MODULES=${MODULES%,}

            echo "Modules string after trim: $MODULES"

            # 如果没有检测到模块，则抛出错误
            if [ -z "$MODULES" ]; then
              echo "Error: No modules detected for building, please check your commit content."
              exit 1
            fi

            # 将逗号分隔的模块列表转换为JSON数组格式（使用最兼容的方法）
            # 使用awk将逗号分隔的字符串转换为JSON数组
            MODULES_JSON=$(echo "$MODULES" | awk -F',' '{
                json = "["
                for (i = 1; i <= NF; i++) {
                    if (i > 1) json = json ","
                    json = json "\"" $i "\""
                }
                json = json "]"
                print json
            }')
            
            echo -n "$MODULES_JSON" > /tmp/apps-to-build
            echo "Modules to build (JSON format): $MODULES_JSON"

            # 确保脚本以成功状态退出
            exit 0