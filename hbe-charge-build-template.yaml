apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: hbe-charge-build-template
  namespace: argo-cicd
spec:
  securityContext:
    runAsNonRoot: false
  serviceAccountName: argo
  volumes:
    - name: shared-workspace
      persistentVolumeClaim:
        claimName: shared-data-pvc-2
    - name: credentials
      secret:
        secretName: deployment-ssh-keys
  templates:
    - name: hbe-charge-build
      inputs:
        parameters:
          - name: branch
          - name: apps-to-build
      volumes:
        - name: shared-workspace
          persistentVolumeClaim:
            claimName: shared-data-pvc-2
      container:
        image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/library/golang:1.23.8-alpine
        imagePullPolicy: IfNotPresent
        workingDir: /src
        volumeMounts:
          - name: shared-workspace
            mountPath: /src
        command: ["/bin/sh", "-c"]
        args:
          - |
            #!/bin/sh
            set -e

            APPS="{{inputs.parameters.apps-to-build}}"
            echo "Apps to build: $APPS"

            if [ -z "$APPS" ]; then
              echo "No apps to build"
              echo -n "Build successful" > /tmp/build-output
              exit 0
            fi

            # 创建Go模块缓存目录
            mkdir -p /go-cache

            # 将apps列表写入临时文件并逐行处理，避免循环问题
            echo "$APPS" | tr ',' '\n' > /tmp/apps.txt

            # 逐行读取应用名称并构建
            while IFS= read -r app; do
              if [ -z "$app" ]; then
                continue
              fi
              
              echo "Building module: $app"
              
              if [ ! -d "app/$app" ]; then
                echo "Error: Directory app/$app does not exist"
                exit 1
              fi
              
              cd app/$app
              
              if [ ! -f "main.go" ]; then
                echo "Error: main.go not found in app/$app"
                exit 1
              fi
              
              echo "Running go build..."
              go build -o main main.go
              
              if [ ! -f "main" ]; then
                echo "Error: Failed to build main executable"
                exit 1
              fi
              
              mkdir -p /var/jenkins_home/$app
              cp main /var/jenkins_home/$app/
              
              # 计算程序文件的哈希值和文件大小（与 Jenkinsfile 功能保持一致）
              echo "计算哈希值..."
              sha256sum main > /var/jenkins_home/$app/main.sha256
              # 使用 Alpine Linux 兼容的方式获取文件大小
              wc -c < main > /var/jenkins_home/$app/main.size
              
              echo "Successfully built and processed $app"
              cd ../..
            done < /tmp/apps.txt

            rm -f /tmp/apps.txt
            echo -n "Build successful" > /tmp/build-output
            echo "All modules built successfully"
      outputs:
        parameters:
          - name: build-output
            valueFrom:
              path: /tmp/build-output
