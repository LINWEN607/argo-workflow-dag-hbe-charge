apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: hbe-charge-deploy-template
  namespace: argo-cicd
spec:
  securityContext:
    runAsNonRoot: false
  serviceAccountName: argo
  volumes:
    - name: shared-workspace
      persistentVolumeClaim:
        claimName: shared-data-pvc-2
    - name: credentials
      secret:
        secretName: deployment-ssh-keys
  templates:
    - name: hbe-charge-deploy
      inputs:
        parameters:
          - name: target-branch
          - name: project-name
          - name: git-commit
          - name: commit-message
          - name: build-time
          - name: git-url
          - name: app-name
      volumes:
        - name: shared-workspace
          persistentVolumeClaim:
            claimName: shared-data-pvc-2
        - name: credentials
          secret:
            secretName: deployment-ssh-keys
      container:
        image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/linuxserver/openssh-server:version-9.7_p1-r4
        imagePullPolicy: IfNotPresent
        workingDir: /src/hbe-charge
        volumeMounts:
          - name: shared-workspace
            mountPath: /src
          - name: credentials
            mountPath: /credentials
        env:
          - name: LC_ALL
            value: C
          - name: LANG
            value: C
        command: ["/bin/sh", "-c"]
        args:
          - |
            set -e

            APP_NAME="{{inputs.parameters.app-name}}"
            TARGET_BRANCH="{{inputs.parameters.target-branch}}"
            PROJECT_NAME="{{inputs.parameters.project-name}}"
            GIT_COMMIT="{{inputs.parameters.git-commit}}"
            COMMIT_MESSAGE="{{inputs.parameters.commit-message}}"
            BUILD_TIME="{{inputs.parameters.build-time}}"
            GIT_URL="{{inputs.parameters.git-url}}"

            # Extract branch name from full ref if needed
            case "$TARGET_BRANCH" in
              refs/heads/*)
                BRANCH_NAME="${TARGET_BRANCH#refs/heads/}"
                echo "Debug: Extracted branch name from full ref: $BRANCH_NAME"
                ;;
              *)
                BRANCH_NAME="$TARGET_BRANCH"
                echo "Debug: Using branch name as is: $BRANCH_NAME"
                ;;
            esac

            echo "Debug: APP_NAME=$APP_NAME"
            echo "Debug: TARGET_BRANCH=$TARGET_BRANCH"
            echo "Debug: BRANCH_NAME=$BRANCH_NAME"
            echo "Debug: PROJECT_NAME=$PROJECT_NAME"
            printf "Debug: GIT_COMMIT=%s\n" "$GIT_COMMIT"
            echo "Debug: BUILD_TIME=$BUILD_TIME"
            echo "Debug: GIT_URL=$GIT_URL"

            # Set deployment configuration based on branch
            case "$BRANCH_NAME" in
              "dev")
                HOST="192.168.30.111"
                REMOTE_BASE_PATH="/usr/local/www/go/$PROJECT_NAME"
                PORT="22"
                KEY_FILE="dev-ssh-key"
                ;;
              "main")
                HOST="192.168.0.210"
                REMOTE_BASE_PATH="/usr/local/www/go/src/$PROJECT_NAME"
                PORT="22"
                KEY_FILE="main-ssh-key"
                ;;
              "release")
                HOST="20.77.170.190"
                REMOTE_BASE_PATH="/usr/local/www/go/src/$PROJECT_NAME"
                PORT="22"
                KEY_FILE="release-ssh-key"
                ;;
              *)
                echo "Error: No deployment configuration for branch $BRANCH_NAME"
                exit 1
                ;;
            esac

            echo "Debug: Selected HOST=$HOST"
            echo "Debug: Selected PORT=$PORT"
            echo "Debug: Selected KEY_FILE=$KEY_FILE"

            # Check if branch-specific key file exists, otherwise use default
            if [ -n "$KEY_FILE" ] && [ -f "/credentials/$KEY_FILE" ]; then
              FINAL_KEY_FILE="$KEY_FILE"
              echo "Debug: Using branch-specific key file: $FINAL_KEY_FILE"
            elif [ -f "/credentials/privatekey" ]; then
              FINAL_KEY_FILE="privatekey"
              echo "Debug: Using default key file: $FINAL_KEY_FILE"
            else
              echo "Error: No SSH key file found"
              echo "Debug: Available files in credentials workspace:"
              ls -la "/credentials/"
              exit 1
            fi

            # Fix SSH key permissions by copying to a temporary file
            cp "/credentials/$FINAL_KEY_FILE" /tmp/temp_key
            chmod 600 /tmp/temp_key

            # Check if app name is provided
            if [ -z "$APP_NAME" ]; then
              echo "No app to deploy"
              exit 0
            fi

            # Process the app
            echo "Debug: Processing app: $APP_NAME"

            # Construct full remote path with app name
            REMOTE_PATH="$REMOTE_BASE_PATH/app/$APP_NAME"
            BACKUP_PATH="/data/backup"

            echo "Deploying app $APP_NAME to $HOST:$REMOTE_PATH"

            # 1. Stop service
            echo "Stopping service for app $APP_NAME..."
            ssh -o StrictHostKeyChecking=no -i /tmp/temp_key root@$HOST -p $PORT "
              echo \"Stopping service hbecharge_$APP_NAME...\"
              systemctl stop hbecharge_$APP_NAME || echo \"Service stop failed or service not running\"
            "

            # 2. Backup existing files
            echo "Backing up existing files for app $APP_NAME..."
            ssh -o StrictHostKeyChecking=no -i /tmp/temp_key root@$HOST -p $PORT "
              BASE_NAME=\"hbe-charge\"
              DEPLOY_PATH=\"$REMOTE_PATH\"
              FILE_PATH=\"\$DEPLOY_PATH/main\"
              echo \"Backing up files...\"
              if [ -f \"\$FILE_PATH\" ]; then
                mkdir -p $BACKUP_PATH/hbe-charge/$APP_NAME
                TIMESTAMP=\$(date +%Y%m%d%H%M%S)
                BACKUP_FILE=\"$BACKUP_PATH/hbe-charge/$APP_NAME/\$BASE_NAME-\$TIMESTAMP\"
                cp \"\$FILE_PATH\" \"\$BACKUP_FILE\"
                echo \"Backed up file to: \$BACKUP_FILE\"
                ls -t $BACKUP_PATH/hbe-charge/$APP_NAME/\$BASE_NAME-* 2>/dev/null | tail -n +4 | xargs -r rm -f
                echo \"Cleaned up old backup files\"
              else
                echo \"No existing file found to backup\"
              fi
            "

            # 3. Transfer new files - ONLY transfer the main executable file
            echo "Transferring main executable file for app $APP_NAME..."
            if [ -f "app/$APP_NAME/main" ]; then
              echo "Local main executable file exists:"
              ls -la "app/$APP_NAME/main"
              
              # Get file size and hash before transfer
              FILE_SIZE=$(stat -c%s "app/$APP_NAME/main")
              FILE_HASH=$(sha256sum "app/$APP_NAME/main" | cut -d" " -f1)
              echo "File size: $FILE_SIZE bytes"
              echo "File hash: $FILE_HASH"
              
              scp -i /tmp/temp_key -P $PORT -o StrictHostKeyChecking=no "app/$APP_NAME/main" root@$HOST:$REMOTE_PATH/
              echo "Main executable file transfer completed"
            else
              echo "Error: Main executable file app/$APP_NAME/main does not exist"
              exit 1
            fi

            # 4. Start service
            echo "Starting service for app $APP_NAME..."
            ssh -o StrictHostKeyChecking=no -i /tmp/temp_key root@$HOST -p $PORT "
              echo \"Starting service hbecharge_$APP_NAME...\"
              systemctl start hbecharge_$APP_NAME
            "

            # 5. Create or update meta file
            echo "Updating meta file for app $APP_NAME..."
            # 正确处理BUILD_TIME中的特殊字符，避免过度转义
            BUILD_TIME_FORMATTED=$(echo "$BUILD_TIME" | sed 's/T/ /g' | sed 's/+/_/g')
            
            # 处理commit message中的特殊字符
            ESCAPED_COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed 's/"/\\"/g')
            
            # Create meta content
            echo "# 构建元数据信息" > /tmp/meta_content.txt
            echo "软件版本号: $APP_NAME\_$BUILD_TIME_FORMATTED" >> /tmp/meta_content.txt
            echo "发布日期和时间: $BUILD_TIME_FORMATTED" >> /tmp/meta_content.txt
            echo "归属的项目: $PROJECT_NAME" >> /tmp/meta_content.txt
            echo "代码仓库: $GIT_URL" >> /tmp/meta_content.txt
            echo "分支: $BRANCH_NAME" >> /tmp/meta_content.txt
            echo "对应 revision: $GIT_COMMIT" >> /tmp/meta_content.txt
            echo "二进制文件大小: $FILE_SIZE bytes" >> /tmp/meta_content.txt
            echo "二进制文件 hash(sha256): $FILE_HASH" >> /tmp/meta_content.txt
            echo "主要修改描述: $ESCAPED_COMMIT_MESSAGE" >> /tmp/meta_content.txt
            echo "" >> /tmp/meta_content.txt
            echo "构建时间: $BUILD_TIME_FORMATTED" >> /tmp/meta_content.txt
            echo "构建状态: SUCCESS" >> /tmp/meta_content.txt
            
            # Transfer metadata file to remote server
            scp -i /tmp/temp_key -P $PORT -o StrictHostKeyChecking=no /tmp/meta_content.txt root@$HOST:$REMOTE_PATH/meta.log
            
            # Verify the meta file was transferred
            echo "Verifying meta file on remote server:"
            ssh -o StrictHostKeyChecking=no -i /tmp/temp_key root@$HOST -p $PORT "
              if [ -f $REMOTE_PATH/meta.log ]; then
                echo 'Meta file exists on remote server:'
                tail -n 20 $REMOTE_PATH/meta.log
              else
                echo 'Error: Meta file was not found on remote server'
              fi
            "
            
            echo "Successfully deployed app $APP_NAME"

            # Clean up temporary files
            rm -f /tmp/temp_key /tmp/meta_content.txt

            echo "App deployed successfully"